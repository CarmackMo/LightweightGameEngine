# 3D 游戏引擎

## 介绍

A lightweight game engine that is developed by C/C++ and targeted on the Windows operating system. The systems and components of this game engine include:

- **Cross-platform rendering pipeline**
- **Art asset pipeline**
- **Job system**
- **Maya plugin**
- **Utility components**
- **Math library**

英文版项目介绍可见此链接:
[English](README.md)



<br></br>

## 目录

+ [3D图形库](#GraphicsLibrary)

+ [渲染管线](#RenderingPipeline)

+ [资产管线](#AssetPipeline)

+ [任务系统](#JobSystem)

+ [Maya插件](#MayaPlugin)

+ [通用组件](#Utility)
    - [单例](#Singleton)
    - [智能指针](#SmartPointers)

+ [数学库](#Math)
    - [Mathf](#Mathf)
    - [向量](#Vector)
    - [矩阵](#Matrix)

+ [未来计划](#FuturePlan)



<br></br>
<a id="RenderingPipeline"></a>

# 渲染管线

游戏引擎实现了一个跨平台的渲染管线。该渲染管线同时支持 **x64** 和 **Win32** 平台。在x64平台下渲染管线使用了 **Direct3D 12** 作为渲染后端；而在 Win32 平台下，渲染管线使用了 **OpenGL 4.6** 作为渲染后端。
由于在不同平台上使用了不同的渲染后端和逻辑，为此渲染管线对其底层逻辑进行了封装，并为外部系统的调用提供了通用、独立于平台的接口。

为了方便理解，下面附上渲染管线的架构图：

![Rendering Pipeline Architecture](Documents/Images/RenderingPipeline.png)

+ 从渲染管线的视角来看，游戏引擎可以分为两个部分：*“应用端”* 和 *“渲染端”*。应用端和渲染端采用了 **生产者-消费者设计模式（Producer-Consumer Design Pattern）**，其中应用端作为生产者负责计算并“生产”渲染数据，而渲染端则作为消费者使用这些数据来渲染游戏画面。

+ 应用端和渲染端各自维护着一个独立的线程。应用端在 *“主线程（main thread）”* 上运行，该线程负责游戏逻辑执行和除渲染外的所有其他引擎功能。相对应地，渲染端在 *“渲染线程（rendering thread）”* 上运行，其专门负责所有与渲染相关的任务。

+ 在游戏引擎初始化时，主线程负责初始化游戏引擎所有的系统，这其中包括了渲染端。此外也是主线程负责为渲染端创建一个新的线程来作为渲染线程。     

+ 完成初始化后，主线程进入引擎的主循环（main loop）。主循环专门用于运行整体的引擎功能和游戏逻辑。主循环更新可以进一步划分为 *“系统更新”（System Update）* 和 *“模拟更新”（Simulation Update）*。
    - 模拟更新负责的是对游戏逻辑的逐帧更新，例如物理更新，摄像机更新，gameplay更新等。模拟更新的频率与游戏的帧率同步，且可以由用户自定义。
    - 另一方面，系统更新负责执行引擎系统的功能，例如监听用户输入，更新UI，向渲染端提交渲染数据等。系统更新的频率与CPU时钟周期（CPU clock cycle）同步。
    - 系统更新和模拟更新不一样的迭代频率可能会引发一些渲染问题。以渲染一个移动的模型为例，模型的变换矩阵由模拟更新负责计算，每一帧才会更新一次（大多数游戏使用30FPS或60FPS的帧率）。但系统更新会在每个CPU时钟周期向渲染端提交模型的变换矩阵进行渲染。如果系统更新直接向渲染端提交由模拟更新计算得到的变换矩阵，那么渲染得到的模型移动将会是断断续续的。

        对这类问题的解决方案是基于系统时间计算渲染数据的预测值，并将这些预测数据而不是原始数据提交给渲染端进行渲染。

    - 在目前的实现中，需要提交的渲染数据包括了：系统时间、摄像机信息、每个游戏对象的网格、着色器和变换矩阵等。

+ 渲染数据提交至渲染端后，后续的渲染步骤由渲染端负责处理。与应用端类似，渲染端完成了自身的初始化后会进入渲染循环（Render loop），负责游戏运行期的画面渲染。如前所述，应用端和渲染端分别充当了渲染数据的“生产者”和“消费者”，而游戏引擎使用了两个不同的线程来运行应用端和渲染端，致使应用端和渲染端之间存在线程同步问题。为此，作为数据消费者的渲染线程会在每一个渲染周期阻塞地等待应用端完成渲染数据的提交后，再对数据进行渲染。
    - 但是，使用阻塞机制进行同步并不是一个很好的设计，因为这会极大地拖慢引擎的运行性能。然而其优点在于实现相对简单，线程安全性较好且更易于维护。考虑到该游戏引擎的架构相对简单，因此采用了这种设计来实现应用端和渲染端的同步。

+ 渲染端维护着两个用来暂存渲染数据的缓冲区，分别是：*“接收缓冲区（Receiver Buffer）”* 和 *“渲染缓冲区（Render Buffer）”*。接收缓冲区负责接收应用端提交的渲染数据，而渲染缓冲区则将渲染数据从操作系统的内存中提交到GPU的内存进行渲染。在一个渲染周期中，应用端计算好的渲染数据会首先被提交到接收缓冲区进行暂存。在应用端完成所有数据的提交后，渲染管线会把渲染数据从接收缓冲区迁移到渲染缓冲区。完成数据转移后，接收缓冲区会继续接收应用端提交的用于下一个周期的渲染数据，而渲染缓冲区则会把当前周期的渲染数据提交给GPU进行渲染。
    - 考虑到当前的渲染管线采用阻塞等待的方法接收数据，单一缓冲区就足以从应用端接收并随后提交数据给GPU。而选择使用双缓冲区的设计是考虑到在未来的更新中，届时渲染管线可能从单线程转为多线程。对于多线程渲染管线，若只采用一个缓冲区完成上述步骤，那么正在被提交给GPU的数据很可能会被应用端提交的新数据给覆盖，因此需要双重或甚至多重缓冲区的设计。
    
+ 在渲染缓冲区完成数据提交后，渲染管线最后调用图形库的绘制命令进行画面的渲染。


+ ## 渲染组件

    为了支持渲染管线的运作，该游戏引擎实现了渲染数据类，例如网格类（mesh class），效果类（effect class），常缓冲区类（constant buffer class）。由于渲染管线是跨平台的，因此这些渲染组件的底层逻辑也采用了跨平台实现并进行了封装，只对外暴露了平台独立（platform-independent）的接口以供调用。

    此外，如前所述渲染管线采用了 “生产者-消费者” 设计模式，因而渲染数据在渲染管线的运行过程中涉及了大量的迁移。为了更好地管理渲染数据的创建、拷贝、迁移和清理，渲染数据使用了 **观察者设计模式（Observer Design Pattern）** 进行开发。



<br></br>
<br></br>
<a id="FuturePlan"></a>

# 未来计划

+ ## 渲染管线

    1. **多线程优化:** 计划采取有着更优运行性能的线程同步策略，以简化渲染过程并确保线程之间更好的同步。

    2. **扩展平台和后端支持:** 计划令渲染管线支持更多的平台，例如 Linux, MacOS, 和移动端平台等。此外，也有计划扩展3D图形库的支持，如增加对Vulkan和Metal的支持。

    3. **后处理效果:** 有计划整合各种后处理效果以提高视觉美感。例如色调映射（tone mapping）、模糊（blurring）和屏幕空间环境遮挡（Screen Space Ambient Occlusion）等。

    4. **基于物理的渲染（PBR）:** 有意向整合与物理相关的渲染技术。如实时阴影（real-time shadows）、全局光照（global illumination）等。
