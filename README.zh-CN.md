# 轻量级游戏引擎

## 介绍

一个基于C/C++开发的轻量级游戏引擎。该游戏引擎的系统和组件包括：

- **渲染管线**
- **物理系统**
- **资产管线**
- **任务队列系统**
- **音频系统**
- **通用组件（单例对象，智能指针，等）**
- **简易数学库**


关于游戏引擎各个组件的具体描述，请参考该引擎的[技术文档](TechDoc.zh-CN.md).


英文版项目介绍可见此链接:
[English](README.md)



<br>

## 引擎展示

| **小游戏展示 - 雷电II** |
|         :---           |
| 下面的视频展示了一款基于该游戏引擎开发的竖版射击小游戏，该小游戏的玩法参考了 *"雷电II"*。玩家是视频中彩色方块，需要躲避下落的岩石、外星人和敌人的子弹。 <br> 小游戏的开发使用了渲染管线，物理系统，音频系统等引擎功能。该小游戏可以通过[此链接](Documents/Builds/ScrollShooterDemo)下载并运行。|
| [<img src="Documents/Images/MiniGameDemo.png" width="800px">](https://www.youtube.com/watch?v=xEG6YPtX860) |


| **渲染管线展示** |
|       :---      |
| 下面的GIF演示了渲染管线的功能，例如网格渲染、网格变换、顶点颜色渲染、特效着色器等。<br> GIF中的两个白盒人物是使用本引擎提供的Maya插件导出的第三方模型。（详见[资产管线章节]((#AssetPipeline))） <br> 光照、阴影和纹理渲染等功能的开发正在进行中。 |
| <img src="Documents/Gifs/RenderingPipelineDemo.gif" width="800px" height="455px"> |


| **物理系统展示 - BVH树** |
|          :---           | 
| 下面的GIF演示了在游戏中使用BVH树（包围体积层次数）来管理碰撞体，并且展示了BVH树在运行期的实时更新。<br> 在实际渲染中，BVH树由蓝色框架表示，而碰撞体则由各种颜色的框架表示。 |
|  <img src="Documents/Gifs/BVHTreeDemo.gif" width="800px" height="455px"> |


| **物理系统展示 - 碰撞检测和碰撞解决** |
|                 :---               | 
| 下面的GIF展示了游戏运行时的碰撞检测和碰撞解决过程。<br> 在实际渲染中，立方体框架代表 AABB（轴对齐包围盒）碰撞器；菱形框架代表球体碰撞器。 <br> 框架颜色的含义如下：绿色表示普通碰撞器，黄色表示静态碰撞器，粉红色表示触发器碰撞器，红色则表示碰撞器当前正在与其他碰撞器发生碰撞。 <br> 需要注意的是，静态碰撞器和触发器碰撞器都不参与碰撞解决。 |
|  <img src="Documents/Gifs/CollisionDemo.gif" width="800px" height="455px"> |


| **游戏引擎 Release** |
|       :---          | 
| 该游戏引擎可以通过[此链接](Documents/Builds/EngineDemo)下载并运行。其中 *"MyGame.exe"* 文件是游戏引擎的运行文件。 |
| 引擎运行时，请使用以下控制方案： <br> 控制其中一个AABB碰撞器："A"键、"W"键、"S"键、"D"键、"R"键、"F"键。 <br> 控制摄像机："左箭头"键、"右箭头"键、"上箭头"键、"下箭头"键、"Delete"键、"Home"键、"End"键、"Page Down"键。 |



<br></br>

## 目录

+ [渲染管线](#RenderingPipeline)

+ [物理系统](#PhysicsSystem)

+ [资产管线](#AssetPipeline)

+ [任务队列系统](#JobSystem)

+ [通用组件](#Utility)
    - [单例](#Singleton)
    - [智能指针](#SmartPointers)

+ [数学库](#Math)
    - [Mathf](#Mathf)
    - [向量](#Vector)
    - [矩阵](#Matrix)

+ [进行中工作](#WorkInProgress)

+ [未来计划](#FuturePlan)





<br></br>
<a id="RenderingPipeline"></a>

# 渲染管线

游戏引擎实现了一个跨平台的渲染管线。该渲染管线同时支持 **x64** 和 **Win32** 平台。在x64平台下渲染管线使用了 **Direct3D 12** 作为渲染后端；而在 Win32 平台下，渲染管线使用了 **OpenGL 4.6** 作为渲染后端。
由于在不同平台上使用了不同的渲染后端和逻辑，为此渲染管线对其底层逻辑进行了封装，并为外部系统的调用提供了通用、独立于平台的接口。

关于渲染管线的更多信息，请参考技术文档的[渲染管线](./TechDoc.zh-CN.md#RenderingPipeline)章节。


## 架构设计

为了方便理解，下面附上渲染管线的架构图：

![Rendering Pipeline Architecture](Documents/Images/RenderingPipeline.png)


+ ## 渲染组件

    为了支持渲染管线的运作，该游戏引擎实现了渲染数据类，例如网格类（mesh class），效果类（effect class），常缓冲区类（constant buffer class）。由于渲染管线是跨平台的，因此这些渲染组件的底层逻辑也采用了跨平台实现并进行了封装，只对外暴露了平台独立（platform-independent）的接口以供调用。

    此外，如前所述渲染管线采用了 “生产者-消费者” 设计模式，因而渲染数据在渲染管线的运行过程中涉及了大量的迁移。为了更好地管理渲染数据的创建、拷贝、迁移和清理，渲染数据使用了 **观察者设计模式（Observer Design Pattern）** 进行开发。




<br></br>
<br></br>
<a id="PhysicsSystem"></a>

# 物理系统

物理系统包含了多个组件，包括物理对象的实现、刚体动力学的模拟，以及碰撞检测和解决机制。

该物理系统实现了包括 **变换（transform）**、**刚体（rigid bodies）** 和 **碰撞器（collider）** 在内的物理对象。

对于碰撞检测，该物理系统实现了碰撞检测的 **碰撞初筛（broad phase）** 和 **碰撞细筛（narrow phase）**。在碰撞初筛检测中，物理引擎实现了 **Sweep And Prune** 算法和 **包围体层次结构（BVH）** 算法，用户可以根据实际的运行需求来决定使用哪一种算法。

对于碰撞解决，物理系统采用了基于解坐标约束的碰撞解决机制。此外，物理系统实现了针对动态碰撞器（dynamic collider）、静态碰撞器（static collider）和触发器碰撞器（trigger collider）提供了特定的碰撞解决策略，以应对这些对象类型之间不同的需求和相互作用。

关于物理系统的更多信息，请参考技术文档的[物理系统](./TechDoc.zh-CN.md#PhysicsSystem)章节。


## 架构设计

为了方便理解，下面附上渲物理系统的流程图：

<img src="Documents/Images/PhysicsSystem.png" width="550px" >





<br></br>
<br></br>
<a id="AssetPipeline"></a>

# 资产管线

从某种角度来说，游戏引擎可以理解为负责为游戏的开发和运行提供所需的特定功能的库。因此对于游戏引擎来说，游戏资产（例如gameobject，mesh，shader，user data等）都属于外部数据。游戏引擎充当这些数据的“消费者”。因此，这些数据不应硬编码到游戏引擎的源代码中。相反，它们应存储在磁盘上并在运行时加载到游戏中。资产管线的主要作用是监督和管理游戏资产从创建、到存储、再到加载到游戏中的整个过程。

与渲染管线一样，资产管线也构成了一个复杂的系统。但资产管线比较特殊的地方在于，其许多功能不会直接作用与游戏中。此外，一些游戏资产来源于外部软件（例如，模型资产来自3D建模软件 **Maya**）。因此，资产管线也专门实现了外部软件的插件以对资产进行管理。

关于资产管线的更多信息，请参考技术文档的[资产管线](./TechDoc.zh-CN.md#AssetPipeline)章节。


## 架构设计

为了方便理解，以下部分以资产管线对模型资产的管理为例，展示了资产管线的架构和流程。

![Asset Pipeline Architecture](Documents/Images/AssetPipeline.png)





<br></br>
<br></br>
<a id="JobSystem"></a>

# 任务队列系统

任务队列系统设计为使用多线程技术来管理游戏引擎各项任务的执行。

任务队列系统为用户提供了一系列API，以便管理任务的执行和任务队列系统本身的运行。用户可以以根据运行时的需求动态地增加任务队列（Job Queue）并指派任务执行单元（Job Runner），从而提高游戏引擎的性能。此外，用户可以根据任务队列系统的工作负载删除多余的任务队列和空闲的任务执行单元，以优化游戏引擎的资源利用。

此外，任务队列系统实现了一个自动化工作负载调整机制。当创建新的任务队列时，用户可以选择是否在任务队列上应用此机制。该机制根据任务队列中待处理任务的数量动态地创建或删除任务执行单元。从而确保了资源利用和任务执行效率之间的最佳平衡。

关于任务队列系统的更多信息，请参考技术文档的[任务队列系统](./TechDoc.zh-CN.md#JobSystem)章节。


## 架构设计

为了方便对任务队列系统架构的理解，以下是任务队列系统简易的架构图，概述了其关键组件及之间的相互运作。

![Job System Architecture](Documents/Images/JobSystem.png)


## 自动化工作负载调整（Automatic Workload Adjustment） 

在游戏引擎的运行期中，任务队列需要执行的任务数量可能会随时间而变化。在一方面，如果有太多的任务等待被执行却没有足够的任务执行单元去消化这些任务，这回导致游戏性能下降。而在另一方面，如果任务执行单元的数量远远超出实际需求，那些闲置的任务执行单元将对系统资源造成。找到任务执行单元的需求和供应之间的平衡，以优化程序性能和资源利用至关重要。

当前的自动化工作负载调整机制提供了一种简单的策略来解决上述问题。每个任务队列都维持着一个 `工作负载管理器` 用于工作负载调整。工作负载管理器记录着其对应的任务队列的工作负载状态。工作负载管理器使用两个状态来标识工作负载状态：队列中的任务是否太多或太少。这些状态是基于正在等待被执行的任务数量与之相应的阈值之间的比较来切换的。任务队列系统的私有任务队列会循环地执行一个检测程序，其会不断地检查每个工作负载管理器的状态，并相应地动态调整任务执行单元的数量，根据运行需求添加或删除它们。





<br></br>
<br></br>
<a id="Utility"></a>

# 通用组件

<a id="Singleton"></a>

## 单例

请参考[英文版介绍文档](./README.md#Singleton)。

关于单例的更多信息，请参考技术文档的[单例](./TechDoc.zh-CN.md#Singleton)章节。


<br>
<a id="SmartPointers"></a>

## 智能指针

请参考[英文版介绍文档](./README.md#SmartPointers)。

关于智能指针的更多信息，请参考技术文档的[智能指针](./TechDoc.zh-CN.md#SmartPointers)章节。





<br></br>
<br></br>
<a id="Math"></a>

# 简易数学库

<a id="Mathf"></a>

## Mathf.h

请参考[英文版介绍文档](./README.md#Mathf)。

关于 Mathf.h 库的更多信息，请参考技术文档的[Mathf](./TechDoc.zh-CN.md#Mathf)章节。


<br>
<a id="Vector"></a>

## 向量

请参考[英文版介绍文档](./README.md#Vector)。

关于向量类的更多信息，请参考技术文档的[向量](./TechDoc.zh-CN.md#Vector)章节。


<br>
<a id="Matrix"></a>

## 矩阵

请参考[英文版介绍文档](./README.md#Matrix)。

关于矩阵类的更多信息，请参考技术文档的[矩阵](./TechDoc.zh-CN.md#Matrix)章节。





<br></br>
<br></br>
<a id="WorkInProgress"></a>

# 进行中工作

+ ## 光照渲染

+ ## 贴图材质





<br></br>
<br></br>
<a id="FuturePlan"></a>

# 未来计划

+ ## 渲染管线

    1. **多线程优化:** 计划采取有着更优运行性能的线程同步策略，以简化渲染过程并确保线程之间更好的同步。

    2. **扩展平台和后端支持:** 计划令渲染管线支持更多的平台，例如 Linux, MacOS, 和移动端平台等。此外，也有计划扩展3D图形库的支持，如增加对Vulkan和Metal的支持。

    3. **后处理效果:** 有计划整合各种后处理效果以提高视觉美感。例如色调映射（tone mapping）、模糊（blurring）和屏幕空间环境遮挡（Screen Space Ambient Occlusion）等。

    4. **基于物理的渲染（PBR）:** 有意向整合与物理相关的渲染技术。如实时阴影（real-time shadows）、全局光照（global illumination）等。


+ ## 资产管线

    1. **自动化：** 当前资产管线中的许多过程都依赖于用户的手动干预。例如Maya插件的安装。为了改进这一点，计划在未来的开发中使资产管线的运作更加自动化。

    2. **资产编辑器：** 在当前的实现下，对资产文件的任何编辑都需要用户直接操作源代码。这个过程操作难度大，而且容易出错，特别是对于那些不熟悉基于代码的操作的人。计划在未来开发一个提供图形用户界面(GUI)的资产编辑器。

    3. **错误检测机制：** 当前资产管线对数据的读取和处理采用了较为单一的错误检测机制。虽然它解决了基本的错误场景，但在全面性方面还有提高的空间。未来的开发打算引入一个更为稳健和全面的错误检测机制。